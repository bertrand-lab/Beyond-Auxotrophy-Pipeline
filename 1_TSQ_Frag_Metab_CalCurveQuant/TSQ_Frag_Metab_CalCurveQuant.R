# This script will:
  # make calibration curves after normalizing to BMIS
  # make linear models for calibration curves
  # apply quant with calibration curves
  # export final peaks and pair to cell numbers



# Setup -------------------------------------------------------------------


# Load required packages into environment
library(ggplot2)
library(dplyr)
library(raster)
library(MetBrewer)
library(tidyr)
library(car)
library(ggpubr)
library(stringr)

# Start working directory the TSQ_Frag_Metab_060623 folder
setwd("~/Dropbox (Bertrand Lab)/Bertrand Lab's shared workspace/Catalina/Summer_2022/1_FracyPibo_Beyond_Auxotrophy/BA_Manuscript/BA_FragPibo_Quotas_Pipeline")

# Set working directory
setwd("./TSQ_Frag_Metab_RAW")

# Get calibration curve data
CalCurve_df <- read.csv("ER3_149_Frag_Catalina_01_Cal03022022_output.csv")

# Change wd to CalCurveQuant folder
setwd("../1_TSQ_Frag_Metab_CalCurveQuant")

# Load in list that checks for calibration curve
cal_data_sum <- read.csv("TSQ_Metab_CalSum.csv")

# Data Cleanup ------------------------------------------------------------


# Create df for calibration curves
CalCurve_df <- CalCurve_df %>% 
  mutate(
    Molecule.Name = replace(
      Molecule.Name,
      Molecule.Name == "Dimethyl-benzimidazole (DMB)", # Replace DMB name for just acronym
      "DMB"
    )
  ) %>%
  dplyr::filter(!grepl("blk", Replicate.Name)) # Remove data from blanks

# Create df with no heavy compound data
CalCurve_cals <- CalCurve_df %>% 
  filter(!grepl('heavy', Molecule.Name)) # Remove data from heavy peaks

# Get Normalized Peaks (divide each light QC peak by each heavy QC peak) ------------

# Create a list of heavy compounds to normalize to
heavy_compounds <- c("B1", "B2", "B12-CN", "B7")

# Create a function that does the normalization
norm_peaks <- function(compound_name) {
  # Index for compound from CalCurve_df
  heavy <-
    CalCurve_df %>% filter(Molecule.Name == paste(compound_name, "-heavy", sep = ""))
  
  # Amend areas of the heavy compound to the CalCurve_cals df
  CalCurve_cals[paste("Heavy", compound_name, "Peaks", sep = ".")] <-
    heavy$Total.Area
  
  # Calculate normalized peaks by dividing each compound by the heavy peak
  CalCurve_cals[paste("Heavy", compound_name, "Norm", sep = ".")] <-
    CalCurve_cals$Total.Area / CalCurve_cals[paste("Heavy", compound_name, "Peaks", sep = ".")]
  
  assign("CalCurve_cals", CalCurve_cals, envir = globalenv())
  
}

# Apply with list of heavy compounds
lapply(heavy_compounds, norm_peaks)





# Select BMIS (best matched internal standard) and produce final peak to be used for plotting and quantification  -------------------------------------------------------------

# Notes: 
# Generate final peaks based on BMIS used 
# Will use "matching compounds" (ex: B12's to CNB12, B1 to heavy B1, B2 to heavy B2). 
# For others, will use a compound as BMIS if improves cv by >30%
# B7 was not matched to heavy B7 due to an increase in cv


setwd("../0_TSQ_Frag_Metab_BMIS")

# Load in BMIS results (generated by TSQ_Frag_Metab_BMIS.R )
BMIS.Data <- read.csv("QC_BMIS_results_sum.csv") %>% 
  dplyr::select(Molecule.Name, BMIS_used) %>%
  mutate(BMIS_used = str_replace_all(BMIS_used, "CNB12", "B12-CN")) # rename cnb12
  

# Join BMIS and calibration curve data
CalCurve_BMIS<-
  left_join(CalCurve_cals, BMIS.Data, by = "Molecule.Name") %>%
  dplyr::select(
    # select only needed columns
    Replicate.Name,
    Molecule.Name,
    Total.Area,
    Heavy.B1.Norm,
    Heavy.B2.Norm,
    `Heavy.B12-CN.Norm`,
    Heavy.B7.Norm,
    BMIS_used
  )  %>% 
  mutate(BMIS_col_name = paste("Heavy.", BMIS_used, ".Norm", sep = "")) %>%
  dplyr::filter(!grepl("heavy",Replicate.Name)) # remove heavy entries


# Function for selecting which measure to use
# Script looks at each line of BMIS. If "none", there is no best matched internal standard and the script will make final measure the unnormalized one
# If not none, match BMIS to the heavy column and use this value

for (i in 1:nrow(CalCurve_BMIS)){
  if (CalCurve_BMIS$BMIS_used[i] == "none"){
    CalCurve_BMIS$Final_Peak[i] <-  CalCurve_BMIS$Total.Area[i]
  } 
   else {
     CalCurve_BMIS$Final_Peak[i] <- CalCurve_BMIS[i,as.character(CalCurve_BMIS$BMIS_col_name[i])]
   }
}



# Calculate LOD's and LOQ's for each compound with a authentic standard ---------

# Prepare and LOQ/LOD df
LODQ_df <- CalCurve_BMIS %>% 
  filter(grepl("p5", Replicate.Name)) %>% # grab all .5 picomolar spikes
  group_by(Molecule.Name) %>%
  dplyr::summarise(
    sd_peak = sd(Final_Peak), # calculate standard dev. (sd)
    LOD = 3 * sd(Final_Peak), # Limit of detection is 3 times the sd of the peak
    LOQ = 5 * sd(Final_Peak) # Limit of quantification is 5 times the sd of the peak
  )

# Narrow df to only include those with a curve
LODQ_df <- LODQ_df[ LODQ_df$Molecule.Name %in% cal_data_sum$Molecule.Name, ]

# Export list of LOQ/D
write.csv(LODQ_df, file = "LODQ_export.csv")

# Remove entries that don't have calibration curves
cal_data_sum <- filter(cal_data_sum, Cal_done == "Y") 

# Narrow calibration dataframe to only include those with a curve
CalCurve_BMIS <- CalCurve_BMIS[ CalCurve_BMIS$Molecule.Name %in% cal_data_sum$Molecule.Name, ]

# Change working dir. to the calcurve quant folder
setwd("../1_TSQ_Frag_Metab_CalCurveQuant")

# Load lookup file that relates sample names to amount spiked
# 1 and 5 is how much spiked (if 1, amounts in sample name are correct. ex: p5fmol = 0.5 fmol spike. if 5, 5x that. ex: p5fmol = 2.5 fmol )
spike_amounts <- read.csv("spike_amount_calcurve.csv")

# Match correct spike amount next to each replicate
# The B12's and DMB were spiked in 1/5 conc of other authentic standards
cal_spike <-
  left_join(CalCurve_BMIS, spike_amounts, by = "Replicate.Name") %>% 
  inner_join(cal_data_sum, by = "Molecule.Name") %>%
  mutate(spike_amount_corr = NULL) # Add a blank column for corrected spike amounts 


# Make a loop that selects the correct spike amount to use (either 1x for B12's and DMB or 5x for everything else)
for (i in 1:nrow(cal_spike)) {
  if (cal_spike$Cal_amount[i] == "5") {
    cal_spike$spike_amount_corr[i] <- cal_spike$spiked_5[i]
  }
  else{
    cal_spike$spike_amount_corr[i] <- cal_spike$spiked_1[i]
  }
}


# Trim down to only useful info
cal_spike <-
  cal_spike %>% dplyr::select(Replicate.Name,
                              Molecule.Name,
                              BMIS_used,
                              Final_Peak,
                              spike_amount_corr)
  





# Get Linear Models for Compounds with Curves -----------------------------

# Create function to make linear models from calibration curves
lm_calcurve <- function(molecule.name) { # accept parameter molecule.name
  
  
  assign(paste(molecule.name, "curve", sep = "_"), # create an object named [molecule name]_curve
         {
           subset(cal_spike, cal_spike$Molecule.Name == molecule.name)  %>% # grab data for that molecule
             
             # For Ado and methyl-B12, use only bottom 3 points for this (50 and 100 fmol spikes show the same response)
             {
               if (molecule.name == "B12-Ado" | # if b12-ado or me
                   molecule.name == "B12-Me")
                 filter(., spike_amount_corr <= 10) # make spike amount less than or equal to 10            
               else(molecule.name != "B12-Ado" | # if b12-ado or me
                      molecule.name != "B12-Me")
                  filter(., spike_amount_corr >= 0)
             }
           
         }, envir = globalenv())
  
  
  
  assign(paste(molecule.name, "lm", sep = "_"), # create an object named [molecule name]_lm
         {
           lm(spike_amount_corr ~ Final_Peak , data = get0(paste(molecule.name, "curve", sep = "_"))) #calculate lm
         }, envir = globalenv())
  
  assign(paste(molecule.name, "rsq", sep = "_"),
         {
           as.numeric(summary(get0(paste(molecule.name, "lm", sep = "_")))$r.squared) # get r squared value for fit to line
         }, envir = globalenv())
  
}

# List of compounds to get calibration curves for
calcurve_molecules <- unique(cal_spike$Molecule.Name)

# Apply calibration to all molecules
lapply(calcurve_molecules, lm_calcurve)

# Put all calibration data into a df and export
list_df <- data.frame(mget(ls(pattern = "rsq$"))) %>% # find all df's with rsq in name
  t() # transpose
rownames(list_df) <- str_sub(rownames(list_df), 1, str_length(rownames(list_df))-4) # remove rsq from row name to just get molecule name
list_df <-
  data.frame(list_df) %>% dplyr::rename("rsq" = "list_df") %>% # change col name
  mutate(norm = case_when(rsq > .5 ~ "Y",
                         rsq < .5 ~ "N")) # if rsquared is less than .5, no calibration curve is applied

# write out dataframe with rsq values and if calibration curve used
write.csv(list_df, "rsq_metab.csv")



# Load in Sample Data and Match to BMIS ------------------------------------------------------
# Change wd
setwd("../TSQ_Frag_Metab_RAW")

metab_data <- read.csv("ER3_149_Frag_Catalina_01_03022022_output.csv") %>% 
  dplyr::select(Replicate.Name, Molecule.Name, Total.Area) %>% 
  dplyr::filter(nchar(Replicate.Name) < 7)

# Function for normalizing
norm_peaks_samples <- function(compound_name) {
  # Index for compound from CalCurve_df
  
  heavy <-
    metab_data %>% filter(Molecule.Name == paste(compound_name, "-heavy", sep = ""))
  
  # Amend areas of the heavy compound to the CalCurve_cals df
  metab_data[paste("Heavy", compound_name, "Peaks", sep = ".")] <-
    heavy$Total.Area
  
  # Calculate normalized peaks by dividing each compound by the heavy peak
  metab_data[paste("Heavy", compound_name, "Norm", sep = ".")] <-
    metab_data$Total.Area / metab_data[paste("Heavy", compound_name, "Peaks", sep = ".")]
  
  assign("metab_data", metab_data, envir = globalenv())
  
}

# Apply function over all 4 heavy compounds
lapply(heavy_compounds, norm_peaks_samples)

# Add back in BMIS data
metab_data_norm <-
  left_join(metab_data, BMIS.Data, by = "Molecule.Name") %>% # Join sample metab data to sample info
  mutate(BMIS_col_name = paste("Heavy.", BMIS_used, ".Norm", sep = "")) %>% # Make a column name for BMIS
  dplyr::filter(!grepl("heavy", Molecule.Name)) %>% # Remove heavy entries
  mutate(Final_Peak = NA) # create empty column for final peaks

# Loop to select right peak
for (i in 1:nrow(metab_data_norm)){ # for all of metab_data_norm
  if (metab_data_norm$BMIS_used[i] == "none"){ # if no BMIS used
    metab_data_norm$Final_Peak[i] <-  metab_data_norm$Total.Area[i] # make the final peak the original area
  } else {
    metab_data_norm$Final_Peak[i] <- metab_data_norm[i,as.character(metab_data_norm$BMIS_col_name[i])] # if there is a BMIS, make the final peak the BMIS used
  }
}



# Add Cell Number Data ----------------------------------------------------


# Change wd 
setwd("../1_TSQ_Frag_Metab_CalCurveQuant")

# Load in file with cells per filter data
cell_nos <- read.csv("B_sample_info_loading_220116.csv") %>%
  mutate(Extract.ID = sprintf("%02d", Extract.ID)) %>% # add a zero to the single digit sample numbers
  rename(Replicate.Name = Extract.ID) # rename column

# Fill out CMA-2-139-2 mgC_cell from avg of other treatments
cell_nos$mgC_cell[cell_nos$Culture_ID == "CMA-2-139-2"] <- mean(c(cell_nos$mgC_cell[cell_nos$Culture_ID == "CMA-2-139-3"], cell_nos$mgC_cell[cell_nos$Culture_ID == "CMA-2-139-1"] ))

# Split replicate name to remove injection number
metab_data_norm <- metab_data_norm %>% separate(Replicate.Name, c("Replicate.Name", NA))

# Join data to sample info (treatment, cells)
metab_data_samples_info <-
  left_join(metab_data_norm, cell_nos, by = "Replicate.Name") %>% 
  filter(Temperature.Treatment == "6") %>% 
  dplyr::select(
    Replicate.Name,
    Total.Area,
    Molecule.Name,
    BMIS_used,
    Final_Peak,
    Temperature.Treatment,
    B12.Treatment,
    cells_on_column,
    mgC_cell,
    culture_replicate_no
  ) %>%
  mutate(mgC_loaded = cells_on_column * mgC_cell) %>% # Get fmol/mgC
  mutate(B12.Treatment = factor( # Change B12 to factor for plotting
    B12.Treatment,
    levels = c("Y", "N"),
    labels = c("+", "-")
  ))


                                      
# Correct Curves --------------------------------------------

# Function for getting r squared and equation onto plot
# From https://groups.google.com/forum/#!topic/ggplot2/1TgH-kG5XMA
lm_eqn <- function(df){
  m <- lm(Final_Peak ~ spike_amount_stadd_corr, df);
  eq <- substitute(italic(y) == a + b %.% italic(x)*","~~italic(r)^2~"="~r2, 
                   list(a = format(unname(coef(m)[1]), digits = 2),
                        b = format(unname(coef(m)[2]), digits = 2),
                        r2 = format(summary(m)$r.squared, digits = 3)))
  as.character(as.expression(eq));
}

# Function for generating calibration curve plots 
plot_calcurve <- function(molecule.name) {
  
  
  calcurveplot_df <-
    get0(paste(molecule.name, "curve", sep = "_")) %>% # grab calcurve data
    mutate(spike_amount_stadd_corr = spike_amount_corr - as.numeric(coef(get0(paste(molecule.name, "lm", sep = "_")))["(Intercept)"]))
  
  
  assign(paste("calcurveplot", molecule.name, sep = "_"), # save plot as calcurveplot_[molecule name]
         {
           ggplot(calcurveplot_df, aes(spike_amount_corr, Final_Peak)) +
             geom_point(size = 8) +
             xlab("Spike Amount (fmol)") +
             ylab("Peak Area") +
             theme(text = element_text(size = 20)) +
             ggtitle(paste("Calibration Curve:", molecule.name)) +
             geom_smooth(method = 'lm',
                         formula = y ~ x,
                         fullrange = TRUE)
           
           
         }, envir = globalenv())
  
  # Plot corrected calibration curve
  assign(
    paste("calcurveplotcorr", molecule.name, sep = "_"),
    # save plot as calcurveplot_[molecule name]
    {
      ggplot(calcurveplot_df, aes(spike_amount_stadd_corr, Final_Peak)) +
        geom_point() +
        xlab("Spike Amount (fmol)") +
        ylab("Peak Area") +
        ggtitle(paste("Calibration Curve: ", molecule.name, " (Corrected)")) +
        xlim(0, 1000) +
        geom_smooth(method = 'lm',
                    formula = y ~ x,
                    fullrange = TRUE) +
        geom_hline(
          yintercept = (LODQ_df %>% filter(Molecule.Name == molecule.name))$LOD,
          linetype = 'dotted',
          col = 'red'
        ) +
        geom_hline(
          yintercept = (LODQ_df %>% filter(Molecule.Name == molecule.name))$LOQ,
          linetype = 'dotted',
          col = 'green',
          size = .75
        ) +
        geom_text(x = 300, y = 17, label = lm_eqn(calcurveplot_df), parse = TRUE)
           
           
         }, envir = globalenv())

  # Make corrected lm
  assign(paste(molecule.name, "lmcorr", sep = "_"), # create an object named [molecule name]_lmcorr
         {
           lm(spike_amount_stadd_corr ~ Final_Peak , data = calcurveplot_df) #calculate lm
         }, envir = globalenv())
}

# Apply quant_plot_calcurve function to all analytes
lapply(calcurve_molecules, plot_calcurve)


# Create function for adding LOD/Q
# Index each LOD/Q per analyte and determine if a tech rep is below it
incorp_LODQ <- function(molecule.name) {

  # Get LOD and LOQ
  LOD <- (LODQ_df %>% filter(Molecule.Name == molecule.name))$LOD
  LOQ <- (LODQ_df %>% filter(Molecule.Name == molecule.name))$LOQ

  # Create a dataframe that denotes whether a sample is below LOD or not
  # If sample is below the LOD, make the peak 0
  assign(paste(molecule.name, "df", sep = "_"), # make a df called [molecule name]_df
         {
           metab_data_samples_info %>% filter(Molecule.Name == molecule.name) %>% # look up molecule
             mutate(Below_LOD = case_when( # create a column which states whether a tech rep is below the LOD
               Final_Peak > LOD ~ FALSE, 
               Final_Peak < LOD ~ TRUE
             )) %>%
             mutate(Final_Peak = case_when( # When a techrep is below LOD, assign as 0
               Final_Peak > LOD ~ Final_Peak,
               Final_Peak < LOD ~ 0 
             )) %>%
             mutate(Below_LOQ = case_when( # create a column which states whether a techrep is below LOQ
               Final_Peak > LOQ ~ FALSE,
               Final_Peak < LOQ ~ TRUE
             )) 
             
         }, envir = globalenv())
  }

# Apply function to all analytes
lapply(calcurve_molecules, incorp_LODQ) %>% bind_rows()

# Create df's for all molecules with a calibraion curve
metabs_data_cat <- mget(paste(calcurve_molecules, "df", sep = "_"))

# Concat all analyte's data into a single dataframe 
metabs_data_cat <- do.call("rbind", metabs_data_cat)

# Write relative peak dataset
write.csv(metabs_data_cat, "metabs_data_cat.csv")



# Get Absolute Quant ------------------------------------------------------

# Get recommended norm type
# if >2 samples PER treatment are below LOD, no quant
# if <1/2 samples are below LOD, relative quant 
# If all samples above LOQ, absolute quant
# notify if sample is below LOD

reccomended_norm_df <- metabs_data_cat %>%
    group_by(Replicate.Name, Molecule.Name, B12.Treatment) %>%
    summarise(vote_LOD = sum(Below_LOD),
              vote_LOQ = sum(Below_LOQ)) %>%
    mutate(biorep_LOD = ifelse(vote_LOD < 2, FALSE, TRUE),
           biorep_LOQ = ifelse(vote_LOQ < 2, FALSE, TRUE)) %>% # Is a biorep below the LOD
    group_by(Molecule.Name, B12.Treatment) %>%
    summarise(vote_LOD = sum(biorep_LOD),
              vote_LOQ = sum(biorep_LOQ)) %>%
    mutate(treatment_LOD = ifelse(vote_LOD < 2, FALSE, TRUE),
           treatment_LOQ = ifelse(vote_LOQ < 2, FALSE, TRUE)) %>% # Is a treatment below the LOD
    group_by(Molecule.Name) %>%
    summarise(vote_LOD = sum(treatment_LOD),
              vote_LOQ = sum(treatment_LOQ)) %>%
    mutate(molecule_LOD = ifelse(vote_LOD < 2, FALSE, TRUE),
           molecule_LOQ = ifelse(vote_LOQ < 2, FALSE, TRUE),
           reccomended_norm = ifelse(molecule_LOD == FALSE & molecule_LOQ == FALSE, "abs quant", NA),
           reccomended_norm = ifelse(molecule_LOD == FALSE & molecule_LOQ == TRUE, "rel quant", reccomended_norm),
           reccomended_norm = ifelse(molecule_LOD == TRUE & molecule_LOQ == TRUE, "no quant", reccomended_norm)) %>%
  dplyr::select(Molecule.Name, molecule_LOD, molecule_LOQ, reccomended_norm) %>%
  left_join(cal_data_sum, by = "Molecule.Name") %>%
  dplyr::select(!(Cal_amount))

# Save and export 
 write.csv(reccomended_norm_df, file = "reccomended_norm_df.csv")
 
 # Add back reccomneded norm info to df 
 quant_df <- left_join(metabs_data_cat, reccomended_norm_df, by= "Molecule.Name") %>%
   mutate(norm_units = ifelse(reccomended_norm == "abs quant", "fmol_cell", NA))
 
 
# Function for getting quant from metabolites 
get_quant <- function(quant.molecule){
  
  # Pull df for quant molecule
  molecule_df <- get(paste(quant.molecule, "df", sep = "_"))
  
  # Pull df for corrected linear model 
  lm_corr <- get(paste(quant.molecule, "lmcorr", sep = "_")) 
  
  quant_df <- data.frame(predict(lm_corr, newdata = molecule_df)) %>%
    rename("est_fmol_on_column" = 1) %>%
    cbind(molecule_df %>%
            dplyr::select(Molecule.Name, Replicate.Name, Total.Area)) %>%
    relocate(est_fmol_on_column, .after = last_col())
  
# Add column to metabs_data_cat
  assign("metabs_data_cat", left_join(metabs_data_cat, quant_df, by = c("Molecule.Name" = "Molecule.Name", "Replicate.Name" = "Replicate.Name", "Total.Area" = "Total.Area")), envir = globalenv())
  
  
}
 
# Get list of compunds to get quant for 
quant_list <- reccomended_norm_df %>% filter(reccomended_norm == "abs quant") 
quant_list <- unique(quant_list$Molecule.Name)

# Get quant for all metabs that are recommended for absolute quant 
lapply(quant_list, get_quant) 

# Clean up and calulate per cell and per carbon values 
metabs_data_quant <- metabs_data_cat %>% 
  dplyr::select(!(starts_with("est_fmol_on_column"))) %>%
  mutate(est_fmol_on_column = coalesce(!!!metabs_data_cat[, grepl("est_fmol_on_column", names(metabs_data_cat))])) %>%
  mutate(est_fmol_on_column = ifelse(Below_LOD == TRUE, 0, est_fmol_on_column)) %>%
  left_join(reccomended_norm_df, by = "Molecule.Name") %>%
  mutate(fmol_cell = ifelse(reccomended_norm == "abs quant", est_fmol_on_column/cells_on_column, NA),
         fmol_mgC = ifelse(reccomended_norm == "abs quant", est_fmol_on_column/mgC_loaded, NA),
         peak_cell = ifelse(reccomended_norm != "no quant",
         Final_Peak/cells_on_column, NA))

write.csv(metabs_data_quant, "metabs_data_quant.csv")


