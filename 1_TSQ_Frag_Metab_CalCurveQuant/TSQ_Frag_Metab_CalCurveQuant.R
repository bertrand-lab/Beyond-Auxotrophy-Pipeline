# This script will:
  # make calibration curves after normalizing to BMIS
  # make linear models for calibration curves
  # apply quant with calibration curves
  # export final peaks and pair to cell numbers

# Load required packages into environment
library(ggplot2)
library(dplyr)
library(raster)
library(MetBrewer)
library(tidyr)
library(car)
library(ggpubr)
library(stringr)

# Start working directory the TSQ_Frag_Metab_060623 folder
setwd("~/Dropbox (Bertrand Lab)/Bertrand Lab's shared workspace/Catalina/Summer_2022/1_FracyPibo_Beyond_Auxotrophy/BA_Manuscript/BA_FragPibo_Quotas_Pipeline")

# Set working directory
setwd("./TSQ_Frag_Metab_RAW")

# Get calibration curve data
CalCurve_df <- read.csv("ER3_149_Frag_Catalina_01_Cal03022022_output.csv")

# Change wd to CalCurveQuant folder
setwd("../1_TSQ_Frag_Metab_CalCurveQuant")

# Load in list that checks for calibration curve
cal_data_sum <- read.csv("TSQ_Metab_CalSum.csv")

# Data Cleanup ------------------------------------------------------------


# Create df for calibration curves
CalCurve_df <- CalCurve_df %>% 
  mutate(
    Molecule.Name = replace(
      Molecule.Name,
      Molecule.Name == "Dimethyl-benzimidazole (DMB)", # Replace DMB name for just acronym
      "DMB"
    )
  ) %>%
  dplyr::filter(!grepl("blk", Replicate.Name)) # Remove data from blanks

# Create df with no heavy compound data
CalCurve_cals <- CalCurve_df %>% 
  filter(!grepl('heavy', Molecule.Name)) # Remove data from heavy peaks

# Get Normalized Peaks (divide each light QC peak by each heavy QC peak) ------------

# Create a list of heavy compounds to normalize to
heavy_compounds <- c("B1", "B2", "B12-CN", "B7")

# Create a function that does the normalization
norm_peaks <- function(compound_name) {
  # Index for compound from CalCurve_df
  heavy <-
    CalCurve_df %>% filter(Molecule.Name == paste(compound_name, "-heavy", sep = ""))
  
  # Amend areas of the heavy compound to the CalCurve_cals df
  CalCurve_cals[paste("Heavy", compound_name, "Peaks", sep = ".")] <-
    heavy$Total.Area
  
  # Calculate normalized peaks by dividing each compound by the heavy peak
  CalCurve_cals[paste("Heavy", compound_name, "Norm", sep = ".")] <-
    CalCurve_cals$Total.Area / CalCurve_cals[paste("Heavy", compound_name, "Peaks", sep = ".")]
  
  assign("CalCurve_cals", CalCurve_cals, envir = globalenv())
  
}

# Apply with list of heavy compounds
lapply(heavy_compounds, norm_peaks)





# Select BMIS (best matched internal standard) and produce final peak to be used for plotting and quantification  -------------------------------------------------------------

# Notes: 
# Generate final peaks based on BMIS used 
# Will use "matching compounds" (ex: B12's to CNB12, B1 to heavy B1, B2 to heavy B2). 
# For others, will use a compound as BMIS if improves cv by >30%
# B7 was not matched to heavy B7 due to an increase in cv


setwd("../0_TSQ_Frag_Metab_BMIS")

# Load in BMIS results (generated by TSQ_Frag_Metab_BMIS.R )
BMIS.Data <- read.csv("QC_BMIS_results_sum.csv") %>% 
  dplyr::select(Molecule.Name, BMIS_used) %>%
  mutate(BMIS_used = str_replace_all(BMIS_used, "CNB12", "B12-CN")) # rename cnb12
  

# Join BMIS and calibration curve data
CalCurve_BMIS <-
  left_join(CalCurve_cals, BMIS.Data, by = "Molecule.Name") %>%
  dplyr::select(
    # select only needed columns
    Replicate.Name,
    Molecule.Name,
    Total.Area,
    Heavy.B1.Norm,
    Heavy.B2.Norm,
    `Heavy.B12-CN.Norm`,
    Heavy.B7.Norm,
    BMIS_used
  )  %>% 
  mutate(BMIS_col_name = paste("Heavy.", BMIS_used, ".Norm", sep = "")) %>%
  dplyr::filter(!grepl("heavy",Replicate.Name)) # remove heavy entries


# Function for selecting which measure to use
# Script looks at each line of BMIS. If "none", there is no best matched internal standard and the script will make final measure the unnormalized one
# If not none, match BMIS to the heavy column and use this value

for (i in 1:nrow(CalCurve_BMIS)){
  if (CalCurve_BMIS$BMIS_used[i] == "none"){
    CalCurve_BMIS$Final_Peak[i] <-  CalCurve_BMIS$Total.Area[i]
  } 
   else {
     CalCurve_BMIS$Final_Peak[i] <- CalCurve_BMIS[i,as.character(CalCurve_BMIS$BMIS_col_name[i])]
   }
}



# Calculate LOD's and LOQ's for each compound with a authentic standard ---------

# Prepare and LOQ/LOD df
LODQ_df <- CalCurve_BMIS %>% 
  filter(grepl("p5", Replicate.Name)) %>% # grab all .5 picomolar spikes
  group_by(Molecule.Name) %>%
  dplyr::summarise(
    sd_peak = sd(Final_Peak), # calculate standard dev. (sd)
    LOD = 3 * sd(Final_Peak), # Limit of detection is 3 times the sd of the peak
    LOQ = 5 * sd(Final_Peak) # Limit of quantification is 5 times the sd of the peak
  )

# Narrow df to only include those with a curve
LODQ_df <- LODQ_df[ LODQ_df$Molecule.Name %in% cal_data_sum$Molecule.Name, ]

# Export list of LOQ/D
write.csv(LODQ_df, file = "LODQ_export.csv")

# Remove entries that don't have calibration curves
cal_data_sum <- filter(cal_data_sum, Cal_done == "Y") 

# Narrow calibration dataframe to only include those with a curve
CalCurve_BMIS <- CalCurve_BMIS[ CalCurve_BMIS$Molecule.Name %in% cal_data_sum$Molecule.Name, ]

# Change working dir. to the calcurve quant folder
setwd("../1_TSQ_Frag_Metab_CalCurveQuant")

# Load lookup file that relates sample names to amount spiked
# 1 and 5 is how much spiked (if 1, amounts in sample name are correct. ex: p5fmol = 0.5 fmol spike. if 5, 5x that. ex: p5fmol = 2.5 fmol )
spike_amounts <- read.csv("spike_amount_calcurve.csv")

# Match correct spike amount next to each replicate
# The B12's and DMB were spiked in 1/5 conc of other authentic standards
cal_spike <-
  left_join(CalCurve_BMIS, spike_amounts, by = "Replicate.Name") %>% 
  inner_join(cal_data_sum, by = "Molecule.Name") %>%
  mutate(spike_amount_corr = NULL) # Add a blank column for corrected spike amounts 


# Make a loop that selects the correct spike amount to use (either 1x for B12's and DMB or 5x for everything else)
for (i in 1:nrow(cal_spike)) {
  if (cal_spike$Cal_amount[i] == "5") {
    cal_spike$spike_amount_corr[i] <- cal_spike$spiked_5[i]
  }
  else{
    cal_spike$spike_amount_corr[i] <- cal_spike$spiked_1[i]
  }
}


# Trim down to only useful info
cal_spike <-
  cal_spike %>% dplyr::select(Replicate.Name,
                              Molecule.Name,
                              BMIS_used,
                              Final_Peak,
                              spike_amount_corr)
  





# Get Linear Models for Compounds with Curves -----------------------------

# Create function to make linear models from calibration curves
lm_calcurve <- function(molecule.name) { # accept parameter molecule.name
  
  
  assign(paste(molecule.name, "curve", sep = "_"), # create an object named [molecule name]_curve
         {
           subset(cal_spike, cal_spike$Molecule.Name == molecule.name)  %>% # grab data for that molecule
             
             # For Ado and methyl-B12, use only bottom 3 points for this (50 and 100 fmol spikes show the same response)
             {
               if (molecule.name == "B12-Ado" | # if b12-ado or me
                   molecule.name == "B12-Me")
                 filter(., spike_amount_corr <= 10) # make spike amount less than or equal to 10            
               else(molecule.name != "B12-Ado" | # if b12-ado or me
                      molecule.name != "B12-Me")
                  filter(., spike_amount_corr >= 0)
             }
           
         }, envir = globalenv())
  
  
  
  assign(paste(molecule.name, "lm", sep = "_"), # create an object named [molecule name]_lm
         {
           lm(spike_amount_corr ~ Final_Peak , data = get0(paste(molecule.name, "curve", sep = "_"))) #calculate lm
         }, envir = globalenv())
  
  assign(paste(molecule.name, "rsq", sep = "_"),
         {
           as.numeric(summary(get0(paste(molecule.name, "lm", sep = "_")))$r.squared) # get r squared value for fit to line
         }, envir = globalenv())
  
}

# List of compounds to get calibration curves for
calcurve_molecules <- unique(cal_spike$Molecule.Name)

# Apply calibration to all molecules
lapply(calcurve_molecules, lm_calcurve)

# Put all calibration data into a df and export
list_df <- data.frame(mget(ls(pattern = "rsq$"))) %>% # find all df's with rsq in name
  t() # transpose
rownames(list_df) <- str_sub(rownames(list_df), 1, str_length(rownames(list_df))-4) # remove rsq from row name to just get molecule name
list_df <-
  data.frame(list_df) %>% dplyr::rename("rsq" = "list_df") %>% # change col name
  mutate(norm = case_when(rsq > .5 ~ "Y",
                         rsq < .5 ~ "N")) # if rsquared is less than .5, no calibration curve is applied

# write out dataframe with rsq values and if calibration curve used
write.csv(list_df, "rsq_metab.csv")



# Load in Sample Data and Match to BMIS ------------------------------------------------------
# Change wd
setwd("../TSQ_Frag_Metab_RAW")

metab_data <- read.csv("ER3_149_Frag_Catalina_01_03022022_output.csv") %>% 
  dplyr::select(Replicate.Name, Molecule.Name, Total.Area) %>% 
  dplyr::filter(nchar(Replicate.Name) < 7)

# Function for normalizing
norm_peaks_samples <- function(compound_name) {
  # Index for compound from CalCurve_df
  
  heavy <-
    metab_data %>% filter(Molecule.Name == paste(compound_name, "-heavy", sep = ""))
  
  # Amend areas of the heavy compound to the CalCurve_cals df
  metab_data[paste("Heavy", compound_name, "Peaks", sep = ".")] <-
    heavy$Total.Area
  
  # Calculate normalized peaks by dividing each compound by the heavy peak
  metab_data[paste("Heavy", compound_name, "Norm", sep = ".")] <-
    metab_data$Total.Area / metab_data[paste("Heavy", compound_name, "Peaks", sep = ".")]
  
  assign("metab_data", metab_data, envir = globalenv())
  
}

# Apply function over all 4 heavy compounds
lapply(heavy_compounds, norm_peaks_samples)

# Add back in BMIS data
metab_data_norm <-
  left_join(metab_data, BMIS.Data, by = "Molecule.Name") %>% # Join sample metab data to sample info
  mutate(BMIS_col_name = paste("Heavy.", BMIS_used, ".Norm", sep = "")) %>% # Make a column name for BMIS
  dplyr::filter(!grepl("heavy", Molecule.Name)) %>% # Remove heavy entries
  mutate(Final_Peak = NA) # create empty column for final peaks

# Loop to select right peak
for (i in 1:nrow(metab_data_norm)){ # for all of metab_data_norm
  if (metab_data_norm$BMIS_used[i] == "none"){ # if no BMIS used
    metab_data_norm$Final_Peak[i] <-  metab_data_norm$Total.Area[i] # make the final peak the original area
  } else {
    metab_data_norm$Final_Peak[i] <- metab_data_norm[i,as.character(metab_data_norm$BMIS_col_name[i])] # if there is a BMIS, make the final peak the BMIS used
  }
}



# Add Cell Number Data ----------------------------------------------------


# Change wd 
setwd("../1_TSQ_Frag_Metab_CalCurveQuant")

# Load in file with cells per filter data
cell_nos <- read.csv("B_sample_info_loading_220116.csv") %>%
  mutate(Extract.ID = sprintf("%02d", Extract.ID)) %>% # add a zero to the single digit sample numbers
  rename(Replicate.Name = Extract.ID) # rename column

# Fill out CMA-2-139-2 mgC_cell from avg of other treatments
cell_nos$mgC_cell[cell_nos$Culture_ID == "CMA-2-139-2"] <- mean(c(cell_nos$mgC_cell[cell_nos$Culture_ID == "CMA-2-139-3"], cell_nos$mgC_cell[cell_nos$Culture_ID == "CMA-2-139-1"] ))

# Split replicate name to remove injection number
metab_data_norm <- metab_data_norm %>% separate(Replicate.Name, c("Replicate.Name", NA))

# Join data to sample info (treatment, cells)
metab_data_samples_info <-
  left_join(metab_data_norm, cell_nos, by = "Replicate.Name") %>% 
  filter(Temperature.Treatment == "6") %>% 
  dplyr::select(
    Replicate.Name,
    Total.Area,
    Molecule.Name,
    BMIS_used,
    Final_Peak,
    Temperature.Treatment,
    B12.Treatment,
    cells_on_column,
    mgC_cell,
    culture_replicate_no
  ) %>%
  mutate(mgC_loaded = cells_on_column * mgC_cell) %>% # Get fmol/mgC
  mutate(B12.Treatment = factor( # Change B12 to factor for plotting
    B12.Treatment,
    levels = c("Y", "N"),
    labels = c("+", "-")
  ))


                                      
# Correct Curves --------------------------------------------

# Function for getting r squared and equation onto plot
# From https://groups.google.com/forum/#!topic/ggplot2/1TgH-kG5XMA
lm_eqn <- function(df){
  m <- lm(Final_Peak ~ spike_amount_stadd_corr, df);
  eq <- substitute(italic(y) == a + b %.% italic(x)*","~~italic(r)^2~"="~r2, 
                   list(a = format(unname(coef(m)[1]), digits = 2),
                        b = format(unname(coef(m)[2]), digits = 2),
                        r2 = format(summary(m)$r.squared, digits = 3)))
  as.character(as.expression(eq));
}

# Function for generating calibration curve plots 
plot_calcurve <- function(molecule.name) {
  
  
  calcurveplot_df <-
    get0(paste(molecule.name, "curve", sep = "_")) %>% # grab calcurve data
    mutate(spike_amount_stadd_corr = spike_amount_corr - as.numeric(coef(get0(paste(molecule.name, "lm", sep = "_")))["(Intercept)"]))
  
  
  assign(paste("calcurveplot", molecule.name, sep = "_"), # save plot as calcurveplot_[molecule name]
         {
           ggplot(calcurveplot_df, aes(spike_amount_corr, Final_Peak)) +
             geom_point(size = 8) +
             xlab("Spike Amount (fmol)") +
             ylab("Peak Area") +
             theme(text = element_text(size = 20)) +
             ggtitle(paste("Calibration Curve:", molecule.name)) +
             geom_smooth(method = 'lm',
                         formula = y ~ x,
                         fullrange = TRUE)
           
           
         }, envir = globalenv())
  
  # Plot corrected calibration curve
  assign(
    paste("calcurveplotcorr", molecule.name, sep = "_"),
    # save plot as calcurveplot_[molecule name]
    {
      ggplot(calcurveplot_df, aes(spike_amount_stadd_corr, Final_Peak)) +
        geom_point() +
        xlab("Spike Amount (fmol)") +
        ylab("Peak Area") +
        ggtitle(paste("Calibration Curve: ", molecule.name, " (Corrected)")) +
        xlim(0, 1000) +
        geom_smooth(method = 'lm',
                    formula = y ~ x,
                    fullrange = TRUE) +
        geom_hline(
          yintercept = (LODQ_df %>% filter(Molecule.Name == molecule.name))$LOD,
          linetype = 'dotted',
          col = 'red'
        ) +
        geom_hline(
          yintercept = (LODQ_df %>% filter(Molecule.Name == molecule.name))$LOQ,
          linetype = 'dotted',
          col = 'green',
          size = .75
        ) +
        geom_text(x = 300, y = 17, label = lm_eqn(calcurveplot_df), parse = TRUE)
           
           
         }, envir = globalenv())

  # Make corrected lm
  assign(paste(molecule.name, "lmcorr", sep = "_"), # create an object named [molecule name]_lmcorr
         {
           lm(spike_amount_stadd_corr ~ Final_Peak , data = calcurveplot_df) #calculate lm
         }, envir = globalenv())
}

# Apply quant_plot_calcurve function to all analytes
lapply(calcurve_molecules, plot_calcurve)


# Create function for adding LOD/Q
# Index each LOD/Q per analyte and determine if a tech rep is below it
incorp_LODQ <- function(molecule.name) {

  # Get LOD and LOQ
  LOD <- (LODQ_df %>% filter(Molecule.Name == molecule.name))$LOD
  LOQ <- (LODQ_df %>% filter(Molecule.Name == molecule.name))$LOQ

  # Create a dataframe that denotes whether a sample is below LOD or not
  # If sample is below the LOD, make the peak 0
  assign(paste(molecule.name, "df", sep = "_"), # make a df called [molecule name]_df
         {
           metab_data_samples_info %>% filter(Molecule.Name == molecule.name) %>% # look up molecule
             mutate(Below_LOD = case_when( # create a column which states whether a tech rep is below the LOD
               Final_Peak > LOD ~ FALSE, 
               Final_Peak < LOD ~ TRUE
             )) %>%
             mutate(Final_Peak = case_when( # When a techrep is below LOD, assign as 0
               Final_Peak > LOD ~ Final_Peak,
               Final_Peak < LOD ~ 0 
             )) %>%
             mutate(Below_LOQ = case_when( # create a column which states whether a techrep is below LOQ
               Final_Peak > LOQ ~ FALSE,
               Final_Peak < LOQ ~ TRUE
             )) 
             
         }, envir = globalenv())
  }

# Apply function to all analytes
lapply(calcurve_molecules, incorp_LODQ) %>% bind_rows()

# list of names of analytes
metabs_data <- paste(calcurve_molecules, "df", sep = "_")
metabs_data_cat <- mget(metabs_data)

# Concat all analyte's data into a single dataframe 
metabs_data_cat <- do.call("rbind", metabs_data_cat)

# Write relative peak dataset
write.csv(metabs_data_cat, "metabs_data_cat.csv")



# Get recommended norm type
# if >1/2 samples are below LOD, no quant
# if <1/2 samples are below LOD, relative quant 
# If all samples above LOQ, absolute quant
# notify if sample is below LOD
B1_df$normtype <- "BMIS_cell"
B1_df$normunits <- "fmol_cell"

# Predict quant values from lm
B1_quant <- data.frame(predict(B1_lmcorr, newdata = B1_df)) 
colnames(B1_quant) <- "est_fmol_on_column"
B1_df <- cbind(B1_df, B1_quant)

# Calculate fmol per mg C, cell, and peak per cell
B1_df$fmol_cell <- B1_df$est_fmol_on_column/B1_df$cells_on_column
B1_df$fmol_mgC <- B1_df$est_fmol_on_column/B1_df$mgC_loaded
B1_df$peak_cell <- B1_df$Final_Peak/B1_df$cells_on_column




# B12Ado Quant ----------------------------------------------------------------
# Plot B12Ado curve with lm 
B12Ado_calcurve <- ggplot(`B12-Ado_curve`, aes(spike_amount_corr, Final_Peak)) +
  geom_point(size = 8) +
  xlab("Spike Amount (fmol)") +
  ylab("Peak Area") + 
  theme(text = element_text(size = 20)) +
  ggtitle("Calibration Curve: B12Ado") +
  #  ylim(0,1600000) +
  # xlim(-255, 550) +
  geom_smooth(method='lm', formula= y~x, fullrange = TRUE) 

# Make new df corrected for standard addition
`B12-Ado_curve`$spike_amount_stadd_corr <- `B12-Ado_curve`$spike_amount_corr - as.numeric(coef(`B12-Ado_lm`)["(Intercept)"])

# Plot corrected calibration curve
B12Ado_calcurve_corrected <- ggplot(`B12-Ado_curve`, aes(spike_amount_stadd_corr, Final_Peak)) +
  geom_point() +
  xlab("Spike Amount (fmol)") +
  ylab("Peak Area") + 
  # theme(text = element_text(size = 20)) +
  ggtitle("Calibration Curve: Ado-B12 (Corrected)") +
  #ylim(0,1600000) +
  xlim(0, 15) +
  geom_smooth(method='lm', formula= y~x, fullrange = TRUE) +
  geom_hline(yintercept = (LODQ_df %>% filter(Molecule.Name == "B12-Ado"))$LOD, linetype='dotted', col = 'red') +
  geom_hline(yintercept = (LODQ_df %>% filter(Molecule.Name == "B12-Ado"))$LOQ, linetype='dotted', col = 'green', size = .75) + 
  geom_text(x = 6.5, y = .2, label = lm_eqn(`B12-Ado_curve`), parse = TRUE)

# Make corrected lm
`B12-Ado_lm_corr` <- lm(spike_amount_stadd_corr ~ Final_Peak , data = `B12-Ado_curve`)

#Creating a data frame with B12Ado peaks from samples 
B12Ado_df <- metab_data_samples_info %>% filter(Molecule.Name == "B12-Ado")
B12Ado_peak_df <- B12Ado_df %>% dplyr::select(Final_Peak) 
colnames(B12Ado_peak_df) <- "Final_Peak"

B12Ado_df_expraw <- B12Ado_df

# Make an ado B12 plot for all reps
# B12Ado_df$technical_rep <- c("1", "2", "3")
# ggplot(data = B12Ado_df, aes(fill = technical_rep, alpha = B12.Treatment, x = Replicate.Name, y = Final_Peak)) +
#   geom_bar(position = "dodge", stat="identity") +
#   geom_hline(yintercept = (LODQ_df %>% filter(Molecule.Name == "B12-Ado"))$LOD, linetype='dotted', col = 'red') +
#   geom_hline(yintercept = (LODQ_df %>% filter(Molecule.Name == "B12-Ado"))$LOQ, linetype='dotted', col = 'green', size = .75) + 
#   xlab("Injection Number") +
#   ylab ("Normalized Peak") + 
#   scale_alpha_manual(values = c(1, .5)) +
#   # scale_x_discrete(labels=c("06" = "06; +B12", "15" = "15; -B12",
#   #                                                "16" = "16; -B12", "24" = "24; +B12", "27" = "27; -B12", "28" = "28; +B12")) +
#   ggtitle("Ado-B12 LOD/LOQ") +
#   theme(text = element_text(size = 20))




# Create an empty column for knowing if sample is below LOD
B12Ado_peak_df$Below_LOD <- NA

# notify if sample is below LOD
for (i in 1:nrow(B12Ado_peak_df)){
  if (B12Ado_peak_df$Final_Peak[i] < (LODQ_df %>% filter(Molecule.Name == "B12-Ado"))$LOD){
    B12Ado_df$Below_LOD[i] <- TRUE
    B12Ado_df$Final_Peak[i] <- 0
  }
  else{
    B12Ado_df$Below_LOD[i] <- FALSE
  }
}

# Create an empty column for knowing if sample is below LOQ
B12Ado_peak_df$Below_LOQ <- NA

# notify if sample is below LOD
for (i in 1:nrow(B12Ado_peak_df)){
  if (B12Ado_peak_df$Final_Peak[i] < (LODQ_df %>% filter(Molecule.Name == "B12-Ado"))$LOQ){
    B12Ado_df$Below_LOQ[i] <- TRUE
  }
  else{
    B12Ado_df$Below_LOQ[i] <- FALSE
  }
}


# Get recommended norm type
# if >1/2 samples are below LOD, no quant
# if <1/2 samples are below LOD, relative quant 
# If all samples above LOQ, absolute quant
# notify if sample is below LOD
B12Ado_df$normtype <- "BMIS_cell"
B12Ado_df$normunits <- "fmol_cell"

# Predict quant values from lm
B12Ado_quant <- data.frame(predict(`B12-Ado_lm_corr`, newdata = B12Ado_peak_df)) 
colnames(B12Ado_quant) <- "est_fmol_on_column"
B12Ado_df <- cbind(B12Ado_df, B12Ado_quant)

# Calculate fmol per mg C and cell
B12Ado_df$fmol_cell <- B12Ado_df$est_fmol_on_column/B12Ado_df$cells_on_column
B12Ado_df$fmol_mgC <- B12Ado_df$est_fmol_on_column/B12Ado_df$mgC_loaded
B12Ado_df$peak_cell <- B12Ado_df$Final_Peak/B12Ado_df$cells_on_column


# B12OH Quant ----------------------------------------------------------------
# Plot B12OH curve with lm 
B12OH_calcurve <- ggplot(`B12-OH_curve`, aes(spike_amount_corr, Final_Peak)) +
  geom_point(size = 8) +
  xlab("Spike Amount (fmol)") +
  ylab("Peak Area") + 
  theme(text = element_text(size = 20)) +
  ggtitle("Calibration Curve: B12OH") +
  #  ylim(0,1600000) +
  # xlim(-255, 550) +
  geom_smooth(method='lm', formula= y~x, fullrange = TRUE) 

# Make new df corrected for standard addition
`B12-OH_curve`$spike_amount_stadd_corr <- `B12-OH_curve`$spike_amount_corr - as.numeric(coef(`B12-OH_lm`)["(Intercept)"])

# Plot corrected calibration curve
B12OH_calcurve_corrected <- ggplot(`B12-OH_curve`, aes(spike_amount_stadd_corr, Final_Peak)) +
  geom_point() +
  xlab("Spike Amount (fmol)") +
  ylab("Peak Area") + 
 # theme(text = element_text(size = 20)) +
  ggtitle("Calibration Curve: OH-B12 (Corrected)") +
  ylim(0,35) +
 # xlim(0, 15) +
  geom_smooth(method='lm', formula= y~x, fullrange = TRUE) +
  geom_hline(yintercept = (LODQ_df %>% filter(Molecule.Name == "B12-OH"))$LOD, linetype='dotted', col = 'red') +
  geom_hline(yintercept = (LODQ_df %>% filter(Molecule.Name == "B12-OH"))$LOQ, linetype='dotted', col = 'green', size = .75) + 
  geom_text(x = 40, y = 30, label = lm_eqn(`B12-OH_curve`), parse = TRUE)

# Make corrected lm
B12OH_lm_corr <- lm(spike_amount_stadd_corr ~ Final_Peak , data = `B12-OH_curve`)

#Creating a data frame with B12OH peaks from samples 
B12OH_df <- metab_data_samples_info %>% filter(Molecule.Name == "B12-OH")
B12OH_peak_df <- B12OH_df %>% dplyr::select(Final_Peak) 
colnames(B12OH_peak_df) <- "Final_Peak"

B12OH_df_expraw <- B12OH_df
# B12OH_df$technical_rep <- c("1", "2", "3")
# ggplot(data = B12OH_df, aes(fill = technical_rep, alpha = B12.Treatment, x = Replicate.Name, y = Final_Peak)) +
#   geom_bar(position = "dodge", stat="identity") +
#   geom_hline(yintercept = (LODQ_df %>% filter(Molecule.Name == "B12-OH"))$LOD, linetype='dotted', col = 'red') +
#   geom_hline(yintercept = (LODQ_df %>% filter(Molecule.Name == "B12-OH"))$LOQ, linetype='dotted', col = 'green', size = .75) + 
#   xlab("Injection Number") +
#   ylab ("Normalized Peak") + 
#   scale_alpha_manual(values = c(1, .5)) +
#   # scale_x_discrete(labels=c("06" = "06; +B12", "15" = "15; -B12",
#   #                                                "16" = "16; -B12", "24" = "24; +B12", "27" = "27; -B12", "28" = "28; +B12")) +
#   ggtitle("OH-B12 LOD/LOQ") +
#   theme(text = element_text(size = 20))

# Create an empty column for knowing if sample is below LOD
B12OH_peak_df$Below_LOD <- NA

# notify if sample is below LOD
for (i in 1:nrow(B12OH_peak_df)){
  if (B12OH_peak_df$Final_Peak[i] < (LODQ_df %>% filter(Molecule.Name == "B12-OH"))$LOD){
    B12OH_df$Below_LOD[i] <- TRUE
    B12OH_df$Final_Peak[i] <- 0
  }
  else{
    B12OH_df$Below_LOD[i] <- FALSE
  }
}

# Create an empty column for knowing if sample is below LOQ
B12OH_peak_df$Below_LOQ <- NA

# notify if sample is below LOD
for (i in 1:nrow(B12OH_peak_df)){
  if (B12OH_peak_df$Final_Peak[i] < (LODQ_df %>% filter(Molecule.Name == "B12-OH"))$LOQ){
    B12OH_df$Below_LOQ[i] <- TRUE
  }
  else{
    B12OH_df$Below_LOQ[i] <- FALSE
  }
}


# Get recommended norm type
# if >1/2 samples are below LOD, no quant
# if <1/2 samples are below LOD, relative quant 
# If all samples above LOQ, absolute quant
# notify if sample is below LOD
B12OH_df$normtype <- "BMIS_cell"
B12OH_df$normunits <- "fmol_cell"

# Predict quant values from lm
B12OH_quant <- data.frame(predict(B12OH_lm_corr, newdata = B12OH_peak_df)) 
colnames(B12OH_quant) <- "est_fmol_on_column"
B12OH_df <- cbind(B12OH_df, B12OH_quant)

# Calculate fmol per mg C and cell
B12OH_df$fmol_cell <- B12OH_df$est_fmol_on_column/B12OH_df$cells_on_column
B12OH_df$fmol_mgC <- B12OH_df$est_fmol_on_column/B12OH_df$mgC_loaded
B12OH_df$peak_cell <- B12OH_df$Final_Peak/B12OH_df$cells_on_column

# B12CN Quant ----------------------------------------------------------------
# Plot B12CN curve with lm 
B12CN_calcurve <- ggplot(`B12-CN_curve`, aes(spike_amount_corr, Final_Peak)) +
  geom_point(size = 8) +
  xlab("Spike Amount (fmol)") +
  ylab("Peak Area") + 
  theme(text = element_text(size = 20)) +
  ggtitle("Calibration Curve: B12CN") +
  #  ylim(0,1600000) +
  # xlim(-255, 550) +
  geom_smooth(method='lm', formula= y~x, fullrange = TRUE) 

# Make new df corrected for standard addition
`B12-CN_curve`$spike_amount_stadd_corr <- `B12-CN_curve`$spike_amount_corr - as.numeric(coef(`B12-CN_lm`)["(Intercept)"])

# Plot corrected calibration curve
B12CN_calcurve_corrected <- ggplot(`B12-CN_curve`, aes(spike_amount_stadd_corr, Final_Peak)) +
  geom_point() +
  xlab("Spike Amount (fmol)") +
  ylab("Peak Area") + 
  #theme(text = element_text(size = 20)) +
  ggtitle("Calibration Curve: CN-B12 (Corrected)") +
  #ylim(0,1600000) +
  #xlim(0, 15) +
  geom_smooth(method='lm', formula= y~x, fullrange = TRUE) +
  geom_hline(yintercept = (LODQ_df %>% filter(Molecule.Name == "B12-CN"))$LOD, linetype='dotted', col = 'red') +
  geom_hline(yintercept = (LODQ_df %>% filter(Molecule.Name == "B12-CN"))$LOQ, linetype='dotted', col = 'green', size = .75) + 
  geom_text(x = 37, y = 15, label = lm_eqn(`B12-CN_curve`), parse = TRUE)

# Make corrected lm
B12CN_lm_corr <- lm(spike_amount_stadd_corr ~ Final_Peak , data = `B12-CN_curve`)

#Creating a data frame with B12CN peaks from samples 
B12CN_df <- metab_data_samples_info %>% filter(Molecule.Name == "B12-CN")
B12CN_peak_df <- B12CN_df %>% dplyr::select(Final_Peak) 
colnames(B12CN_peak_df) <- "Final_Peak"

B12CN_df_expraw <- B12CN_df

# Create an empty column for knowing if sample is below LOD
B12CN_peak_df$Below_LOD <- NA

# notify if sample is below LOD
for (i in 1:nrow(B12CN_peak_df)){
  if (B12CN_peak_df$Final_Peak[i] < (LODQ_df %>% filter(Molecule.Name == "B12-CN"))$LOD){
    B12CN_df$Below_LOD[i] <- TRUE
    B12CN_df$Final_Peak[i] <- 0
  }
  else{
    B12CN_df$Below_LOD[i] <- FALSE
  }
}

# Create an empty column for knowing if sample is below LOQ
B12CN_peak_df$Below_LOQ <- NA

# notify if sample is below LOD
for (i in 1:nrow(B12CN_peak_df)){
  if (B12CN_peak_df$Final_Peak[i] < (LODQ_df %>% filter(Molecule.Name == "B12-CN"))$LOQ){
    B12CN_df$Below_LOQ[i] <- TRUE
  }
  else{
    B12CN_df$Below_LOQ[i] <- FALSE
  }
}


# Get recommended norm type
# if >1/2 samples are below LOD, no quant
# if <1/2 samples are below LOD, relative quant 
# If all samples above LOQ, absolute quant
# notify if sample is below LOD
B12CN_df$normtype <- "none"
B12CN_df$normunits <- "none"

# Predict quant values from lm
B12CN_quant <- data.frame(predict(B12CN_lm_corr, newdata = B12CN_peak_df)) 
colnames(B12CN_quant) <- "est_fmol_on_column"
B12CN_df <- cbind(B12CN_df, B12CN_quant)

# Calculate fmol per mg C and cell
B12CN_df$fmol_cell <- B12CN_df$est_fmol_on_column/B12CN_df$cells_on_column
B12CN_df$fmol_mgC <- B12CN_df$est_fmol_on_column/B12CN_df$mgC_loaded
B12CN_df$peak_cell <- B12CN_df$Final_Peak/B12CN_df$cells_on_column

# B12Me Quant ----------------------------------------------------------------
# Plot B12Me curve with lm 
B12Me_calcurve <- ggplot(`B12-Me_curve`, aes(spike_amount_corr, Final_Peak)) +
  geom_point(size = 8) +
  xlab("Spike Amount (fmol)") +
  ylab("Peak Area") + 
  theme(text = element_text(size = 20)) +
  ggtitle("Calibration Curve: B12Me") +
  #  ylim(0,1600000) +
  # xlim(-255, 550) +
  geom_smooth(method='lm', formula= y~x, fullrange = TRUE) 

# Make new df corrected for standard addition
`B12-Me_curve`$spike_amount_stadd_corr <- `B12-Me_curve`$spike_amount_corr - as.numeric(coef(`B12-Me_lm`)["(Intercept)"])

# Plot corrected calibration curve
B12Me_calcurve_corrected <- ggplot(`B12-Me_curve`, aes(spike_amount_stadd_corr, Final_Peak)) +
  geom_point() +
  xlab("Spike Amount (fmol)") +
  ylab("Peak Area") + 
  #theme(text = element_text(size = 20)) +
  ggtitle("Calibration Curve: Me-B12 (Corrected)") +
  ylim(0,15000) +
  #xlim(0, 15) +
  geom_smooth(method='lm', formula= y~x, fullrange = TRUE) +
  geom_hline(yintercept = (LODQ_df %>% filter(Molecule.Name == "B12-Me"))$LOD, linetype='dotted', col = 'red') +
  geom_hline(yintercept = (LODQ_df %>% filter(Molecule.Name == "B12-Me"))$LOQ, linetype='dotted', col = 'green', size = .75) + 
  geom_text(x = 5.5, y = 14000, label = lm_eqn(`B12-Me_curve`), parse = TRUE)

# Make corrected lm
B12Me_lm_corr <- lm(spike_amount_stadd_corr ~ Final_Peak , data = `B12-Me_curve`)

#Creating a data frame with B12Me peaks from samples 
B12Me_df <- metab_data_samples_info %>% filter(Molecule.Name == "B12-Me")
B12Me_peak_df <- B12Me_df %>% dplyr::select(Final_Peak) 
colnames(B12Me_peak_df) <- "Final_Peak"

B12Me_df_expraw <- B12Me_df

# B12Me_df$technical_rep <- c("1", "2", "3")
# ggplot(data = B12Me_df, aes(fill = technical_rep, alpha = B12.Treatment, x = Replicate.Name, y = Final_Peak)) +
#   geom_bar(position = "dodge", stat="identity") +
#   geom_hline(yintercept = (LODQ_df %>% filter(Molecule.Name == "B12-Me"))$LOD, linetype='dotted', col = 'red') +
#   geom_hline(yintercept = (LODQ_df %>% filter(Molecule.Name == "B12-Me"))$LOQ, linetype='dotted', col = 'green', size = .75) + 
#   xlab("Injection Number") +
#   ylab ("Normalized Peak") + 
#   scale_alpha_manual(values = c(1, .5)) +
#   # scale_x_discrete(labels=c("06" = "06; +B12", "15" = "15; -B12",
#   #                                                "16" = "16; -B12", "24" = "24; +B12", "27" = "27; -B12", "28" = "28; +B12")) +
#   ggtitle("Me-B12 LOD/LOQ") +
#   theme(text = element_text(size = 20))
# 
# Create an empty column for knowing if sample is below LOD
B12Me_peak_df$Below_LOD <- NA

# notify if sample is below LOD
for (i in 1:nrow(B12Me_peak_df)){
  if (B12Me_peak_df$Final_Peak[i] < (LODQ_df %>% filter(Molecule.Name == "B12-Me"))$LOD){
    B12Me_df$Below_LOD[i] <- TRUE
    B12Me_df$Final_Peak[i] <- 0
  }
  else{
    B12Me_df$Below_LOD[i] <- FALSE
  }
}

# Create an empty column for knowing if sample is below LOQ
B12Me_peak_df$Below_LOQ <- NA

# notify if sample is below LOD
for (i in 1:nrow(B12Me_peak_df)){
  if (B12Me_peak_df$Final_Peak[i] < (LODQ_df %>% filter(Molecule.Name == "B12-Me"))$LOQ){
    B12Me_df$Below_LOQ[i] <- TRUE
  }
  else{
    B12Me_df$Below_LOQ[i] <- FALSE
  }
}


# Get recommended norm type
# if >1/2 samples are below LOD, no quant
# if <1/2 samples are below LOD, relative quant 
# If all samples above LOQ, absolute quant
# notify if sample is below LOD
B12Me_df$normtype <- "BMIS_cell"
B12Me_df$normunits <- "fmol_cell"

# Predict quant values from lm
B12Me_quant <- data.frame(predict(B12Me_lm_corr, newdata = B12Me_peak_df)) 
colnames(B12Me_quant) <- "est_fmol_on_column"
B12Me_df <- cbind(B12Me_df, B12Me_quant)

# Calculate fmol per mg C and cell
B12Me_df$fmol_cell <- B12Me_df$est_fmol_on_column/B12Me_df$cells_on_column
B12Me_df$fmol_mgC <- B12Me_df$est_fmol_on_column/B12Me_df$mgC_loaded
B12Me_df$peak_cell <- B12Me_df$Final_Peak/B12Me_df$cells_on_column


# B7 Quant ----------------------------------------------------------------
# Plot B7 curve with lm 
B7_calcurve <- ggplot(B7_curve, aes(spike_amount_corr, Final_Peak)) +
  geom_point(size = 8) +
  xlab("Spike Amount (fmol)") +
  ylab("Peak Area") + 
  theme(text = element_text(size = 20)) +
  ggtitle("Calibration Curve: B7") +
  #  ylim(0,1600000) +
  # xlim(-255, 550) +
  geom_smooth(method='lm', formula= y~x, fullrange = TRUE) 

# Make new df corrected for standard addition
B7_curve$spike_amount_stadd_corr <- B7_curve$spike_amount_corr - as.numeric(coef(B7_lm)["(Intercept)"])

# Plot corrected calibration curve
B7_calcurve_corrected <- ggplot(B7_curve, aes(spike_amount_stadd_corr, Final_Peak)) +
  geom_point() +
  xlab("Spike Amount (fmol)") +
  ylab("Peak Area") + 
 # theme(text = element_text(size = 20)) +
  ggtitle("Calibration Curve: B7 (Corrected)") +
  #ylim(0,1600000) +
#  xlim(0, 15) +
  geom_smooth(method='lm', formula= y~x, fullrange = TRUE) +
  geom_hline(yintercept = (LODQ_df %>% filter(Molecule.Name == "B7"))$LOD, linetype='dotted', col = 'red') +
  geom_hline(yintercept = (LODQ_df %>% filter(Molecule.Name == "B7"))$LOQ, linetype='dotted', col = 'green', size = .75) + 
  geom_text(x = 200, y = 4.5E5, label = lm_eqn(B7_curve), parse = TRUE)

# Make corrected lm
B7_lm_corr <- lm(spike_amount_stadd_corr ~ Final_Peak , data = B7_curve)

#Creating a data frame with B7 peaks from samples 
B7_df <- metab_data_samples_info %>% filter(Molecule.Name == "B7")
B7_peak_df <- B7_df %>% dplyr::select(Final_Peak) 
colnames(B7_peak_df) <- "Final_Peak"


# Create an empty column for knowing if sample is below LOD
B7_peak_df$Below_LOD <- NA

# notify if sample is below LOD
for (i in 1:nrow(B7_peak_df)){
  if (B7_peak_df$Final_Peak[i] < (LODQ_df %>% filter(Molecule.Name == "B7"))$LOD){
    B7_df$Below_LOD[i] <- TRUE
    B7_df$Final_Peak[i] <- 0
  }
  else{
    B7_df$Below_LOD[i] <- FALSE
  }
}

# Create an empty column for knowing if sample is below LOQ
B7_peak_df$Below_LOQ <- NA

# notify if sample is below LOD
for (i in 1:nrow(B7_peak_df)){
  if (B7_peak_df$Final_Peak[i] < (LODQ_df %>% filter(Molecule.Name == "B7"))$LOQ){
    B7_df$Below_LOQ[i] <- TRUE
  }
  else{
    B7_df$Below_LOQ[i] <- FALSE
  }
}


# Get recommended norm type
# if >1/2 samples are below LOD, no quant
# if <1/2 samples are below LOD, relative quant 
# If all samples above LOQ, absolute quant
# notify if sample is below LOD
B7_df$normtype <- "BMIS_cell"
B7_df$normunits <- "fmol_cell"

# Predict quant values from lm
B7_quant <- data.frame(predict(B7_lm_corr, newdata = B7_peak_df)) 
colnames(B7_quant) <- "est_fmol_on_column"
B7_df <- cbind(B7_df, B7_quant)

# Calculate fmol per mg C and cell
B7_df$fmol_cell <- B7_df$est_fmol_on_column/B7_df$cells_on_column
B7_df$fmol_mgC <- B7_df$est_fmol_on_column/B7_df$mgC_loaded
B7_df$peak_cell <- B7_df$Final_Peak/B7_df$cells_on_column

# cHET Quant ----------------------------------------------------------------
# Plot cHET curve with lm 
cHET_calcurve <- ggplot(cHET_curve, aes(spike_amount_corr, Final_Peak)) +
  geom_point(size = 8) +
  xlab("Spike Amount (fmol)") +
  ylab("Peak Area") + 
  theme(text = element_text(size = 20)) +
  ggtitle("Calibration Curve: cHET") +
  #  ylim(0,1600000) +
  # xlim(-255, 550) +
  geom_smooth(method='lm', formula= y~x, fullrange = TRUE) 

# Make new df corrected for standard addition
cHET_curve$spike_amount_stadd_corr <- cHET_curve$spike_amount_corr - as.numeric(coef(cHET_lm)["(Intercept)"])

# Plot corrected calibration curve
cHET_calcurve_corrected <- ggplot(cHET_curve, aes(spike_amount_stadd_corr, Final_Peak)) +
  geom_point() +
  xlab("Spike Amount (fmol)") +
  ylab("Peak Area") + 
 # theme(text = element_text(size = 20)) +
  ggtitle("Calibration Curve: cHET (Corrected)") +
  #ylim(0,1600000) +
  xlim(0, 600) +
  geom_smooth(method='lm', formula= y~x, fullrange = TRUE) +
  geom_hline(yintercept = (LODQ_df %>% filter(Molecule.Name == "cHET"))$LOD, linetype='dotted', col = 'red') +
  geom_hline(yintercept = (LODQ_df %>% filter(Molecule.Name == "cHET"))$LOQ, linetype='dotted', col = 'green', size = .75) + 
  geom_text(x = 220, y = 4.75e6, label = lm_eqn(cHET_curve), parse = TRUE)

# Make corrected lm
cHET_lm_corr <- lm(spike_amount_stadd_corr ~ Final_Peak , data = cHET_curve)

#Creating a data frame with cHET peaks from samples 
cHET_df <- metab_data_samples_info %>% filter(Molecule.Name == "cHET")
cHET_peak_df <- cHET_df %>% dplyr::select(Final_Peak) 
colnames(cHET_peak_df) <- "Final_Peak"


# Create an empty column for knowing if sample is below LOD
cHET_peak_df$Below_LOD <- NA

# notify if sample is below LOD
for (i in 1:nrow(cHET_peak_df)){
  if (cHET_peak_df$Final_Peak[i] < (LODQ_df %>% filter(Molecule.Name == "cHET"))$LOD){
    cHET_df$Below_LOD[i] <- TRUE
    cHET_df$Final_Peak[i] <- 0
  }
  else{
    cHET_df$Below_LOD[i] <- FALSE
  }
}

# Create an empty column for knowing if sample is below LOQ
cHET_peak_df$Below_LOQ <- NA

# notify if sample is below LOD
for (i in 1:nrow(cHET_peak_df)){
  if (cHET_peak_df$Final_Peak[i] < (LODQ_df %>% filter(Molecule.Name == "cHET"))$LOQ){
    cHET_df$Below_LOQ[i] <- TRUE
  }
  else{
    cHET_df$Below_LOQ[i] <- FALSE
  }
}


# Get recommended norm type
# if >1/2 samples are below LOD, no quant
# if <1/2 samples are below LOD, relative quant 
# If all samples above LOQ, absolute quant
# notify if sample is below LOD
cHET_df$normtype <- "BMIS_cell"
cHET_df$normunits <- "fmol_cell"

# Predict quant values from lm
cHET_quant <- data.frame(predict(cHET_lm_corr, newdata = cHET_peak_df)) 
colnames(cHET_quant) <- "est_fmol_on_column"
cHET_df <- cbind(cHET_df, cHET_quant)

# Calculate fmol per mg C and cell
cHET_df$fmol_cell <- cHET_df$est_fmol_on_column/cHET_df$cells_on_column
cHET_df$fmol_mgC <- cHET_df$est_fmol_on_column/cHET_df$mgC_loaded
cHET_df$peak_cell <- cHET_df$Final_Peak/cHET_df$cells_on_column


# FAMP Quant ----------------------------------------------------------------
# Plot FAMP curve with lm 
FAMP_calcurve <- ggplot(FAMP_curve, aes(spike_amount_corr, Final_Peak)) +
  geom_point(size = 8) +
  xlab("Spike Amount (fmol)") +
  ylab("Peak Area") + 
  theme(text = element_text(size = 20)) +
  ggtitle("Calibration Curve: FAMP") +
  #  ylim(0,1600000) +
  # xlim(-255, 550) +
  geom_smooth(method='lm', formula= y~x, fullrange = TRUE) 

# Make new df corrected for standard addition
FAMP_curve$spike_amount_stadd_corr <- FAMP_curve$spike_amount_corr - as.numeric(coef(FAMP_lm)["(Intercept)"])

# Plot corrected calibration curve
FAMP_calcurve_corrected <- ggplot(FAMP_curve, aes(spike_amount_stadd_corr, Final_Peak)) +
  geom_point() +
  xlab("Spike Amount (fmol)") +
  ylab("Peak Area") + 
  #theme(text = element_text(size = 20)) +
  ggtitle("Calibration Curve: FAMP (Corrected)") +
  #ylim(0,1600000) +
 # xlim(0, 15) +
  geom_smooth(method='lm', formula= y~x, fullrange = TRUE) +
  geom_hline(yintercept = (LODQ_df %>% filter(Molecule.Name == "FAMP"))$LOD, linetype='dotted', col = 'red') +
  geom_hline(yintercept = (LODQ_df %>% filter(Molecule.Name == "FAMP"))$LOQ, linetype='dotted', col = 'green', size = .75) +
  geom_text(x = 200, y = 1600000, label = lm_eqn(FAMP_curve), parse = TRUE)

# Make corrected lm
FAMP_lm_corr <- lm(spike_amount_stadd_corr ~ Final_Peak , data = FAMP_curve)

#Creating a data frame with FAMP peaks from samples 
FAMP_df <- metab_data_samples_info %>% filter(Molecule.Name == "FAMP")
FAMP_peak_df <- FAMP_df %>% dplyr::select(Final_Peak) 
colnames(FAMP_peak_df) <- "Final_Peak"


# Create an empty column for knowing if sample is below LOD
FAMP_peak_df$Below_LOD <- NA

# notify if sample is below LOD
for (i in 1:nrow(FAMP_peak_df)){
  if (FAMP_peak_df$Final_Peak[i] < (LODQ_df %>% filter(Molecule.Name == "FAMP"))$LOD){
    FAMP_df$Below_LOD[i] <- TRUE
    FAMP_df$Final_Peak[i] <- 0
  }
  else{
    FAMP_df$Below_LOD[i] <- FALSE
  }
}

# Create an empty column for knowing if sample is below LOQ
FAMP_peak_df$Below_LOQ <- NA

# notify if sample is below LOD
for (i in 1:nrow(FAMP_peak_df)){
  if (FAMP_peak_df$Final_Peak[i] < (LODQ_df %>% filter(Molecule.Name == "FAMP"))$LOQ){
    FAMP_df$Below_LOQ[i] <- TRUE
  }
  else{
    FAMP_df$Below_LOQ[i] <- FALSE
  }
}


# Get recommended norm type
# if >1/2 samples are below LOD, no quant
# if <1/2 samples are below LOD, relative quant 
# If all samples above LOQ, absolute quant
# notify if sample is below LOD
FAMP_df$normtype <- "none"
FAMP_df$normunits <- "none"

# Predict quant values from lm
FAMP_quant <- data.frame(predict(FAMP_lm_corr, newdata = FAMP_peak_df)) 
colnames(FAMP_quant) <- "est_fmol_on_column"
FAMP_df <- cbind(FAMP_df, FAMP_quant)

# Calculate fmol per mg C and cell
FAMP_df$fmol_cell <- FAMP_df$est_fmol_on_column/FAMP_df$cells_on_column
FAMP_df$fmol_mgC <- FAMP_df$est_fmol_on_column/FAMP_df$mgC_loaded
FAMP_df$peak_cell <- FAMP_df$Final_Peak/FAMP_df$cells_on_column


# HET Quant ----------------------------------------------------------------
# Plot HET curve with lm 
HET_calcurve <- ggplot(HET_curve, aes(spike_amount_corr, Final_Peak)) +
  geom_point(size = 8) +
  xlab("Spike Amount (fmol)") +
  ylab("Peak Area") + 
  theme(text = element_text(size = 20)) +
  ggtitle("Calibration Curve: HET") +
  #  ylim(0,1600000) +
  # xlim(-255, 550) +
  geom_smooth(method='lm', formula= y~x, fullrange = TRUE) 

# Make new df corrected for standard addition
HET_curve$spike_amount_stadd_corr <- HET_curve$spike_amount_corr - as.numeric(coef(HET_lm)["(Intercept)"])

# Plot corrected calibration curve
HET_calcurve_corrected <- ggplot(HET_curve, aes(spike_amount_stadd_corr, Final_Peak)) +
  geom_point() +
  xlab("Spike Amount (fmol)") +
  ylab("Peak Area") + 
 # theme(text = element_text(size = 20)) +
  ggtitle("Calibration Curve: HET (Corrected)") +
  #ylim(0,1600000) +
  #xlim(0, 15) +
  geom_smooth(method='lm', formula= y~x, fullrange = TRUE) +
  geom_hline(yintercept = (LODQ_df %>% filter(Molecule.Name == "HET"))$LOD, linetype='dotted', col = 'red') +
  geom_hline(yintercept = (LODQ_df %>% filter(Molecule.Name == "HET"))$LOQ, linetype='dotted', col = 'green', size = .75) + 
  geom_text(x = 200, y = 1.2e7, label = lm_eqn(HET_curve), parse = TRUE)

# Make corrected lm
HET_lm_corr <- lm(spike_amount_stadd_corr ~ Final_Peak , data = HET_curve)

#Creating a data frame with HET peaks from samples 
HET_df <- metab_data_samples_info %>% filter(Molecule.Name == "HET")
HET_peak_df <- HET_df %>% dplyr::select(Final_Peak) 
colnames(HET_peak_df) <- "Final_Peak"


# Create an empty column for knowing if sample is below LOD
HET_peak_df$Below_LOD <- NA

# notify if sample is below LOD
for (i in 1:nrow(HET_peak_df)){
  if (HET_peak_df$Final_Peak[i] < (LODQ_df %>% filter(Molecule.Name == "HET"))$LOD){
    HET_df$Below_LOD[i] <- TRUE
    HET_df$Final_Peak[i] <- 0
  }
  else{
    HET_df$Below_LOD[i] <- FALSE
  }
}

# Create an empty column for knowing if sample is below LOQ
HET_peak_df$Below_LOQ <- NA

# notify if sample is below LOD
for (i in 1:nrow(HET_peak_df)){
  if (HET_peak_df$Final_Peak[i] < (LODQ_df %>% filter(Molecule.Name == "HET"))$LOQ){
    HET_df$Below_LOQ[i] <- TRUE
  }
  else{
    HET_df$Below_LOQ[i] <- FALSE
  }
}


# Get recommended norm type
# if >1/2 samples are below LOD, no quant
# if <1/2 samples are below LOD, relative quant 
# If all samples above LOQ, absolute quant
# notify if sample is below LOD
HET_df$normtype <- "none"
HET_df$normunits <- "none"

# Predict quant values from lm
HET_quant <- data.frame(predict(HET_lm_corr, newdata = HET_peak_df)) 
colnames(HET_quant) <- "est_fmol_on_column"
HET_df <- cbind(HET_df, HET_quant)

# Calculate fmol per mg C and cell
HET_df$fmol_cell <- HET_df$est_fmol_on_column/HET_df$cells_on_column
HET_df$fmol_mgC <- HET_df$est_fmol_on_column/HET_df$mgC_loaded
HET_df$peak_cell <- HET_df$Final_Peak/HET_df$cells_on_column

# HMP Quant ----------------------------------------------------------------
# Plot HMP curve with lm 
HMP_calcurve <- ggplot(HMP_curve, aes(spike_amount_corr, Final_Peak)) +
  geom_point(size = 8) +
  xlab("Spike Amount (fmol)") +
  ylab("Peak Area") + 
  theme(text = element_text(size = 20)) +
  ggtitle("Calibration Curve: HMP") +
  #  ylim(0,1600000) +
  # xlim(-255, 550) +
  geom_smooth(method='lm', formula= y~x, fullrange = TRUE) 

# Make new df corrected for standard addition
HMP_curve$spike_amount_stadd_corr <- HMP_curve$spike_amount_corr - as.numeric(coef(HMP_lm)["(Intercept)"])

# Plot corrected calibration curve
HMP_calcurve_corrected <- ggplot(HMP_curve, aes(spike_amount_stadd_corr, Final_Peak)) +
  geom_point() +
  xlab("Spike Amount (fmol)") +
  ylab("Peak Area") + 
#  theme(text = element_text(size = 20)) +
  ggtitle("Calibration Curve: HMP (Corrected)") +
  #ylim(0,1600000) +
  xlim(0, 750) +
  geom_smooth(method='lm', formula= y~x, fullrange = TRUE) +
  geom_hline(yintercept = (LODQ_df %>% filter(Molecule.Name == "HMP"))$LOD, linetype='dotted', col = 'red') +
  geom_hline(yintercept = (LODQ_df %>% filter(Molecule.Name == "HMP"))$LOQ, linetype='dotted', col = 'green', size = .75) +
  geom_text(x = 300, y = 1400000, label = lm_eqn(HMP_curve), parse = TRUE)

# Make corrected lm
HMP_lm_corr <- lm(spike_amount_stadd_corr ~ Final_Peak , data = HMP_curve)

#Creating a data frame with HMP peaks from samples 
HMP_df <- metab_data_samples_info %>% filter(Molecule.Name == "HMP")
HMP_peak_df <- HMP_df %>% dplyr::select(Final_Peak) 
colnames(HMP_peak_df) <- "Final_Peak"

hmp_plottdf <- HMP_df
hmp_plottdf$technical_rep <- c("1", "2", "3")
hmp_repplot <- ggplot(data = hmp_plottdf, aes(fill = technical_rep, alpha = B12.Treatment, x = Replicate.Name, y = Total.Area)) +
  geom_bar(position = "dodge", stat="identity") +
  geom_hline(yintercept = (LODQ_df %>% filter(Molecule.Name == "HMP"))$LOD, linetype='dotted', col = 'red') +
  geom_hline(yintercept = (LODQ_df %>% filter(Molecule.Name == "HMP"))$LOQ, linetype='dotted', col = 'green', size = .75) +
  xlab("Biological Replicate") +
  ylab ("Normalized Peak") +
  scale_alpha_manual(values = c(1, .5)) +
  theme(text = element_text(size = 20)) +
  facet_grid(.~B12.Treatment, scales = "free") + 
  theme(legend.position = "none") +
  ggtitle("HMP") +
  scale_fill_manual(values=met.brewer("Cross", 5))

# Create an empty column for knowing if sample is below LOD
HMP_peak_df$Below_LOD <- NA

# notify if sample is below LOD
for (i in 1:nrow(HMP_peak_df)){
  if (HMP_peak_df$Final_Peak[i] < (LODQ_df %>% filter(Molecule.Name == "HMP"))$LOD){
    HMP_df$Below_LOD[i] <- TRUE
    HMP_df$Final_Peak[i] <- 0
  }
  else{
    HMP_df$Below_LOD[i] <- FALSE
  }
}

# Create an empty column for knowing if sample is below LOQ
HMP_peak_df$Below_LOQ <- NA

# notify if sample is below LOD
for (i in 1:nrow(HMP_peak_df)){
  if (HMP_peak_df$Final_Peak[i] < (LODQ_df %>% filter(Molecule.Name == "HMP"))$LOQ){
    HMP_df$Below_LOQ[i] <- TRUE
  }
  else{
    HMP_df$Below_LOQ[i] <- FALSE
  }
}


# Get recommended norm type
# if >1/2 samples are below LOD, no quant
# if <1/2 samples are below LOD, relative quant 
# If all samples above LOQ, absolute quant
# notify if sample is below LOD
HMP_df$normtype <- "none"
HMP_df$normunits <- "none"

# Predict quant values from lm
HMP_quant <- data.frame(predict(HMP_lm_corr, newdata = HMP_peak_df)) 
colnames(HMP_quant) <- "est_fmol_on_column"
HMP_df <- cbind(HMP_df, HMP_quant)

# Calculate fmol per mg C and cell
HMP_df$fmol_cell <- HMP_df$est_fmol_on_column/HMP_df$cells_on_column
HMP_df$fmol_mgC <- HMP_df$est_fmol_on_column/HMP_df$mgC_loaded
HMP_df$peak_cell <- HMP_df$Final_Peak/HMP_df$cells_on_column

# SAH Quant ----------------------------------------------------------------
# Plot SAH curve with lm 
SAH_calcurve <- ggplot(SAH_curve, aes(spike_amount_corr, Final_Peak)) +
  geom_point(size = 8) +
  xlab("Spike Amount (fmol)") +
  ylab("Peak Area") + 
  theme(text = element_text(size = 20)) +
  ggtitle("Calibration Curve: SAH") +
  #  ylim(0,1600000) +
  # xlim(-255, 550) +
  geom_smooth(method='lm', formula= y~x, fullrange = TRUE) 

# Make new df corrected for standard addition
SAH_curve$spike_amount_stadd_corr <- SAH_curve$spike_amount_corr - as.numeric(coef(SAH_lm)["(Intercept)"])

# Plot corrected calibration curve
SAH_calcurve_corrected <- ggplot(SAH_curve, aes(spike_amount_stadd_corr, Final_Peak)) +
  geom_point() +
  xlab("Spike Amount (fmol)") +
  ylab("Peak Area") + 
  #theme(text = element_text(size = 20)) +
  ggtitle("Calibration Curve: SAH (Corrected)") +
  #ylim(0,1600000) +
  xlim(0, 650) +
  geom_smooth(method='lm', formula= y~x, fullrange = TRUE) +
  geom_hline(yintercept = (LODQ_df %>% filter(Molecule.Name == "SAH"))$LOD, linetype='dotted', col = 'red') +
  geom_hline(yintercept = (LODQ_df %>% filter(Molecule.Name == "SAH"))$LOQ, linetype='dotted', col = 'green', size = .75) +
  geom_text(x = 210, y = 50000, label = lm_eqn(SAH_curve), parse = TRUE)

# Make corrected lm
SAH_lm_corr <- lm(spike_amount_stadd_corr ~ Final_Peak , data = SAH_curve)

#Creating a data frame with SAH peaks from samples 
SAH_df <- metab_data_samples_info %>% filter(Molecule.Name == "SAH")
SAH_peak_df <- SAH_df %>% dplyr::select(Final_Peak) 
colnames(SAH_peak_df) <- "Final_Peak"


# Create an empty column for knowing if sample is below LOD
SAH_peak_df$Below_LOD <- NA

# notify if sample is below LOD
for (i in 1:nrow(SAH_peak_df)){
  if (SAH_peak_df$Final_Peak[i] < (LODQ_df %>% filter(Molecule.Name == "SAH"))$LOD){
    SAH_df$Below_LOD[i] <- TRUE
    SAH_df$Final_Peak[i] <- 0
  }
  else{
    SAH_df$Below_LOD[i] <- FALSE
  }
}

# Create an empty column for knowing if sample is below LOQ
SAH_peak_df$Below_LOQ <- NA

# notify if sample is below LOD
for (i in 1:nrow(SAH_peak_df)){
  if (SAH_peak_df$Final_Peak[i] < (LODQ_df %>% filter(Molecule.Name == "SAH"))$LOQ){
    SAH_df$Below_LOQ[i] <- TRUE
  }
  else{
    SAH_df$Below_LOQ[i] <- FALSE
  }
}


# Get recommended norm type
# if >1/2 samples are below LOD, no quant
# if <1/2 samples are below LOD, relative quant 
# If all samples above LOQ, absolute quant
# notify if sample is below LOD
SAH_df$normtype <- "BMIS_cell"
SAH_df$normunits <- "fmol_cell"

# Predict quant values from lm
SAH_quant <- data.frame(predict(SAH_lm_corr, newdata = SAH_peak_df)) 
colnames(SAH_quant) <- "est_fmol_on_column"
SAH_df <- cbind(SAH_df, SAH_quant)

# Calculate fmol per mg C and cell
SAH_df$fmol_cell <- SAH_df$est_fmol_on_column/SAH_df$cells_on_column
SAH_df$fmol_mgC <- SAH_df$est_fmol_on_column/SAH_df$mgC_loaded
SAH_df$peak_cell <- SAH_df$Final_Peak/SAH_df$cells_on_column

# SAM Quant ----------------------------------------------------------------
# Plot SAM curve with lm 
SAM_calcurve <- ggplot(SAM_curve, aes(spike_amount_corr, Final_Peak)) +
  geom_point(size = 8) +
  xlab("Spike Amount (fmol)") +
  ylab("Peak Area") + 
  theme(text = element_text(size = 20)) +
  ggtitle("Calibration Curve: SAM") +
  #  ylim(0,1600000) +
  # xlim(-255, 550) +
  geom_smooth(method='lm', formula= y~x, fullrange = TRUE) 

# Make new df corrected for standard addition
SAM_curve$spike_amount_stadd_corr <- SAM_curve$spike_amount_corr - as.numeric(coef(SAM_lm)["(Intercept)"])

# Plot corrected calibration curve
SAM_calcurve_corrected <- ggplot(SAM_curve, aes(spike_amount_stadd_corr, Final_Peak)) +
  geom_point() +
  xlab("Spike Amount (fmol)") +
  ylab("Peak Area") + 
 # theme(text = element_text(size = 20)) +
  ggtitle("Calibration Curve: SAM (Corrected)") +
  #ylim(0,1600000) +
  xlim(0, 700) +
  geom_smooth(method='lm', formula= y~x, fullrange = TRUE) +
  geom_hline(yintercept = (LODQ_df %>% filter(Molecule.Name == "SAM"))$LOD, linetype='dotted', col = 'red') +
  geom_hline(yintercept = (LODQ_df %>% filter(Molecule.Name == "SAM"))$LOQ, linetype='dotted', col = 'green', size = .75) + 
  geom_text(x = 300, y = 90000, label = lm_eqn(SAM_curve), parse = TRUE)

# Make corrected lm
SAM_lm_corr <- lm(spike_amount_stadd_corr ~ Final_Peak , data = SAM_curve)

#Creating a data frame with SAM peaks from samples 
SAM_df <- metab_data_samples_info %>% filter(Molecule.Name == "SAM")
SAM_peak_df <- SAM_df %>% dplyr::select(Final_Peak) 
colnames(SAM_peak_df) <- "Final_Peak"


# Create an empty column for knowing if sample is below LOD
SAM_peak_df$Below_LOD <- NA

# notify if sample is below LOD
for (i in 1:nrow(SAM_peak_df)){
  if (SAM_peak_df$Final_Peak[i] < (LODQ_df %>% filter(Molecule.Name == "SAM"))$LOD){
    SAM_df$Below_LOD[i] <- TRUE
    SAM_df$Final_Peak[i] <- 0
  }
  else{
    SAM_df$Below_LOD[i] <- FALSE
  }
}

# Create an empty column for knowing if sample is below LOQ
SAM_peak_df$Below_LOQ <- NA

# notify if sample is below LOD
for (i in 1:nrow(SAM_peak_df)){
  if (SAM_peak_df$Final_Peak[i] < (LODQ_df %>% filter(Molecule.Name == "SAM"))$LOQ){
    SAM_df$Below_LOQ[i] <- TRUE
  }
  else{
    SAM_df$Below_LOQ[i] <- FALSE
  }
}


# Get recommended norm type
# if >1/2 samples are below LOD, no quant
# if <1/2 samples are below LOD, relative quant 
# If all samples above LOQ, absolute quant
# notify if sample is below LOD
SAM_df$normtype <- "BMIS_cell"
SAM_df$normunits <- "fmol_cell"

# Predict quant values from lm
SAM_quant <- data.frame(predict(SAM_lm_corr, newdata = SAM_peak_df)) 
colnames(SAM_quant) <- "est_fmol_on_column"
SAM_df <- cbind(SAM_df, SAM_quant)

# Calculate fmol per mg C and cell
SAM_df$fmol_cell <- SAM_df$est_fmol_on_column/SAM_df$cells_on_column
SAM_df$fmol_mgC <- SAM_df$est_fmol_on_column/SAM_df$mgC_loaded
SAM_df$peak_cell <- SAM_df$Final_Peak/SAM_df$cells_on_column


metab_quant_export_df <- rbind(B1_df, B12Ado_df, B12CN_df, B12OH_df, B12Me_df, B7_df, cHET_df, FAMP_df, HET_df, HMP_df, SAH_df, SAM_df)
write.csv(metab_quant_export_df, file = "metab_quant_export_df.csv")

b12_quant_expraw <- rbind(B12Ado_df_expraw, B12CN_df_expraw,B12OH_df_expraw, B12Me_df_expraw)
write.csv(b12_quant_expraw, file = "b12_quant_expraw.csv")

# Export plot with all cal curves
ggarrange(B1_calcurve_corrected, B12Ado_calcurve_corrected, B12OH_calcurve_corrected, B12CN_calcurve_corrected, B12Me_calcurve_corrected, B7_calcurve_corrected) 

ggarrange(cHET_calcurve_corrected, FAMP_calcurve_corrected, HET_calcurve_corrected, HMP_calcurve_corrected, SAH_calcurve_corrected, SAM_calcurve_corrected)


